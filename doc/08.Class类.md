# Class 类

## TS 是如何定义类

    //定义类
    class Person {
        constructor () {

        }
        run () {

        }
    }

## 类的修饰符

总共有三个 public private protected

    class Person {
    // 使用 public 修饰符 可以让你定义的变量 内部访问 也可以外部访问 如果不写默认就是 public
    public name: string
    // 使用 private 修饰符 代表定义的变量私有的只能在内部访问 不能在外部访问
    private age: number
    // 使用 protected 修饰符 代表定义的变量私有的只能在内部和继承的子类中访问 不能在外部访问
    protected some: any

    constructor(name: string, age: number, some: any) {
    // 在 TypeScript 是不允许直接在 constructor 定义变量的 需要在 constructor 上面先声明
    this.name = name
    this.age = age
    this.some = some

    }
    run() {}
    }

    let xiaoming = new Person('小明', 28, 1)
    xiaoming.name
    xiaoming.age
    xiaoming.some

    class Man extends Person {
      constructor() {
        super('小黑', 100, 2)
        console.log('Man constructor')
        console.log(this.name)
        console.log(this.age)
        console.log(this.some)
      }
      create() {
        console.log('Man create')
        console.log(this.name)
        console.log(this.age)
        console.log(this.some)
      }
    }

    let man = new Man()
    man.name
    man.age
    man.some

## static 静态属性 和 静态方法

### 用 static 定义的属性 不可以通过 this 去访问 只能通过类名去调用

    class Person {
      // 用 static 定义的属性 不可以通过 this 去访问 只能通过类名去调用
      static nb: string = '123'
      constructor(name: string, age: number, some: any) {
        // this.nb ='nb' // 不可以通过 this 去访问
      }
    }
    console.log('Person.nb', Person.nb)

### static 静态函数 同样也是不能通过 this 去调用 也是通过类名去调用

    class Person {
      public name: string
      // static 静态函数 同样也是不能通过 this 去调用 也是通过类名去调用
      static staticFn() {
        console.log('staticFn')
        return console.log(this.name)
      }

      constructor(name: string, age: number, some: any) {
        this.name = name
        this.age = age
        this.some = some
      }
    }

    Person.staticFn()

### static 静态函数 同样也是不能通过 this 去调用 也是通过类名去调用

    class Person {
      public name: string
      // static 静态函数 同样也是不能通过 this 去调用 也是通过类名去调用
      static staticFn() {
        console.log('staticFn')
        return console.log(this.name)
      }
      static staticFn2() {
        console.log('staticFn2')
        // 需注意： 如果两个函数都是 static 静态的是可以通过 this 互相调用
        return this.staticFn()
      }

      constructor(name: string, age: number, some: any) {
        this.name = name
        this.age = age
        this.some = some
      }
    }

    Person.staticFn()

### 以上 demo 及说明

    //定义类
    class Person {
      // 使用public 修饰符 可以让你定义的变量 内部访问 也可以外部访问 如果不写默认就是public
      public name: string
      // 使用  private 修饰符 代表定义的变量私有的只能在内部访问 不能在外部访问
      private age: number
      // 使用  protected 修饰符 代表定义的变量私有的只能在内部和继承的子类中访问 不能在外部访问
      protected some: any

      // 用static 定义的属性 不可以通过this 去访问 只能通过类名去调用
      static nb: string = '123'
      // static 静态函数 同样也是不能通过 this 去调用 也是通过类名去调用
      static staticFn() {
        console.log('staticFn')
        return console.log(this.name)
      }
      static staticFn2() {
        console.log('staticFn2')
        // 需注意： 如果两个函数都是static 静态的是可以通过this互相调用
        return this.staticFn()
      }

      constructor(name: string, age: number, some: any) {
        // 在TypeScript是不允许直接在constructor 定义变量的 需要在constructor上面先声明
        this.name = name
        this.age = age
        this.some = some
        // this.nb ='nb'  // 不可以通过this 去访问
        // this.staticFn() // 静态函数 同样也是不能通过this 去调用
      }
      run() {}
    }

    console.log('Person.nb', Person.nb)
    Person.staticFn()

    let xiaoming = new Person('小明', 28, 1)
    xiaoming.name
    // xiaoming.age
    // xiaoming.some

    class Man extends Person {
      constructor() {
        super('小黑', 100, 2)
        console.log('Man constructor')
        console.log(this.name)
        // console.log(this.age)
        console.log(this.some)
      }
      create() {
        console.log('Man create')
        console.log(this.name)
        // console.log(this.age)
        console.log(this.some)
      }
    }

    let man = new Man()
    man.name
    // man.age
    // man.some

## interface
